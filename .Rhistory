library(dagitty)
library(ggdag)
adjustmentSets( g, "x", "y" ) # empty set
# The M-bias graph showing that adjustment for
# pre-treatment covariates is not always valid
g <- dagitty( "dag{ x -> y ; x <-> m <-> y }" )
adjustmentSets( g, "x", "y" ) # empty set
g
gg <- ggdag_adjustment_set(.tdy_dag = tidy_dagitty(g), exposure = exposure,
outcome = outcome, ...) + theme_dag()
gg <- ggdag_adjustment_set(.tdy_dag = tidy_dagitty(g), exposure = exposure,
outcome = outcome) + theme_dag()
gg <- ggdag_adjustment_set(.tdy_dag = tidy_dagitty(g), exposure = "x",
outcome = "y") + theme_dag()
adjustmentSets( g, "x", "y" ) # empty set
gg
adjustmentSets( g, "x", "y" ) # empty set
# The M-bias graph showing that adjustment for
# pre-treatment covariates is not always valid
g <- dagitty( "dag{ x -> y ; x <-> m <-> y; z -> y}" )
gg <- ggdag_adjustment_set(.tdy_dag = tidy_dagitty(g), exposure = "x",
outcome = "y") + theme_dag()
gg
PCVEdag <- dagify(
longevity ~ brain+mass,
repertoire ~ brain+cs+flock+hd+color+diet+longevity,
diet ~ hd,
flock ~ diet,
brain ~ mass,
color ~ mass)
ggdag(PCVEdag)
adjustmentSets(x = PCVEdag, outcome = "repertoire", exposure = "longevity")
adjustmentSets(x = PCVEdag, outcome = "repertoire", exposure = "mass")
adjustmentSets(x = PCVEdag, outcome = "repertoire", exposure = "cs")
adjustmentSets(x = PCVEdag, outcome = "repertoire", exposure = "cs", effect = "direct")
adjustmentSets(x = PCVEdag, outcome = "repertoire", exposure = "cs", effect = "total")
adjustmentSets(x = PCVEdag, outcome = "repertoire", exposure = "longevity")
adjustmentSets(x = PCVEdag, outcome = "repertoire", exposure = "color", effect = "total")
adjustmentSets(x = PCVEdag, outcome = "repertoire", exposure = "color", effect = "direct")
library(brms)
# color
adjustmentSets(x = PCVEdag, outcome = "repertoire", exposure = "color", effect = "direct")
# cs
adjustmentSets(x = PCVEdag, outcome = "repertoire", exposure = "cs", effect = "direct")
# Poisson regression for the number of seizures in epileptic patients
fit1 <- brm(
count ~ zBase * Trt + (1|patient), chains = 1,
data = epilepsy, family = poisson(),
prior = prior(normal(0, 10), class = b) +
prior(cauchy(0, 2), class = sd)
)
# generate a summary of the results
summary(fit1)
# Poisson regression for the number of seizures in epileptic patients
fit1 <- brm(
count ~ zBase * Trt + (1|patient), chains = 1,
data = epilepsy, family = poisson(), iter = 100,
prior = prior(normal(0, 10), class = b) +
prior(cauchy(0, 2), class = sd)
)
# generate a summary of the results
summary(fit1)
blogdown:::preview_site()
blogdown:::preview_site()
blogdown::stop_server()
blogdown:::preview_site()
blogdown::stop_server()
blogdown:::preview_site()
blogdown::stop_server()
blogdown:::preview_site()
blogdown::stop_server(); blogdown:::preview_site()
blogdown::stop_server(); blogdown:::preview_site()
blogdown::stop_server(); blogdown:::preview_site()
adjustcolor("#2962ff", alpha.f = 0.1)
blogdown::stop_server(); blogdown:::preview_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::stop_server(); blogdown:::preview_site()
blogdown::stop_server(); blogdown:::preview_site()
blogdown::stop_server(); blogdown:::preview_site()
blogdown::stop_server(); blogdown:::preview_site()
blogdown::stop_server(); blogdown:::preview_site()
blogdown::stop_server(); blogdown:::preview_site()
blogdown::serve_site()
blogdown::stop_server(); blogdown:::preview_site()}
blogdown::stop_server(); blogdown:::preview_site()
blogdown::stop_server(); blogdown:::preview_site()
blogdown:::preview_site()
blogdown::serve_site()
blogdown:::preview_site()
blogdown:::preview_site()
blogdown:::preview_site()
blogdown:::preview_site()
blogdown:::preview_site()
# Chunk 1
#| echo: false
# install/ load packages
sketchy::load_packages(
packages = c(
"knitr",
github = "maRce10/warbleR",
github = "maRce10/baRulho",
"readxl",
"ggplot2",
"viridis",
"DT",
"ape",
"ggtree",
"phytools",
"geiger",
"ggdist",
"ggtree",
"gghalves",
"ggforce",
"cowplot",
"patchwork",
"treeio",
"gridExtra",
"scales"
)
)
source("~/Dropbox/R_package_testing/warbleR/R/internal_functions.R")
# match data and tree tip labels
match_data_tree <- function(data, tree, index) {
if (!is.null(dim(data))){
data <- data[index %in% tree$tip.label, ]
rownames(data) <- index[index %in% tree$tip.label]
} else {
data <- data[index %in% tree$tip.label]
names(data) <- index[index %in% tree$tip.label]
}
# prun tree
tree <- drop.tip(tree, tip = tree$tip.label[!tree$tip.label %in% index])
# return
out <- list(data = data, tree = tree)
return(out)
}
## ggplot themes
theme_function <- theme_classic
presentation_theme <- theme_function(base_size = 20)
no_mayor_grid_theme <- theme_function(base_size = 20) + theme(
panel.grid.major.x = element_blank(),    # Remove horizontal major grid lines
panel.grid.major.y = element_blank()
)
theme_set(presentation_theme)
# Chunk 5
gg_sampling_tru_time <- readRDS("~/Dropbox/Projects/lbh_cultural_evolution_pattern_and_process/output/plots/sampling_tru_time.RDS")
gg_sampling_tru_time
#| out_width = "100%"
gg_var_pc1 <- readRDS("~/Dropbox/Projects/lbh_cultural_evolution_pattern_and_process/output/plots/song_variance_contribution_spectro.RDS")
gg_var_pc1 <- gg_var_pc1 + scale_fill_manual(values = mako(4, begin = 0.1, end = 0.9, direction = 1, alpha = 0.9)[c(1, 3, 2, 4)]) +  theme(legend.position = "none")
# Data for the nested ovals
oval_data <- data.frame(
# label = c("A", "B", "C", "D"),
x0 = c(0, 0, 0, 0),                # Center x position for all ovals
y0 = c(-1.7, -0.4, 0.7, 2.2),                # Center y position for all ovals
b = c(1.5, 3, 4.5, 6),             # Semi-major axis (horizontal radius)
a = c(2, 4, 6, 8) + 1,                 # Semi-minor axis (vertical radius)
text.pos = c(-4.7, -2, 1, 3.2) + 3,  # Radius for each circle
label = rev(c("Sitio", "Lek", "Vecindario\nde canto", "Individuo"))  #
)
oval_data$label <- factor(oval_data$label, levels = (c("Sitio", "Lek", "Vecindario\nde canto", "Individuo")))
# Plot using ggplot2 and ggforce
oval_plot <- ggplot(oval_data) +
geom_ellipse(aes(x0 = x0, y0 = y0, a = a, b = b, angle = 0, fill = label), color = "white") +
geom_text(aes(x = x0, y = text.pos, label = label), size = c(6, 5, 6, 6), color = c( "white",rep("black", 3))) +
scale_fill_viridis_d(option = "G", begin = 0.1, end = 0.9, guide = "none", direction = -1, alpha = 0.6) + # Add labels in the center
# scale_fill_identity() +  # Use the colors as specified in the data
theme_void() +           # Remove background, axes, and grid
theme(legend.position = "none") +
coord_fixed()  #+          # Keep aspect ratio fixed for true ovals
#ylim(c(-12, 6))
cowplot::plot_grid(gg_var_pc1 +    scale_y_continuous(labels = label_percent(), limits = c(0, 0.7)), oval_plot, nrow = 1, rel_widths = c(1, 0.7))
gg_var_pc1
gg_var_pc1 <- ggplot(var_components_pc1_noyear[var_components_pc1_noyear$level != "Residual", ], aes(x = level, y = proportion, fill = grp)) +
geom_bar(stat = "identity") +
# theme_classic(base_size = 22) +
labs(x = "Nivel", y = "Varianza explicada (%)", fill = "Factor") +
theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1)) +
geom_text(aes(label = perc), vjust = -0.5, size = 5) + ylim(c(0, 0.6)) +
scale_y_continuous(labels = label_percent()) +
scale_fill_viridis_d(option = "G", begin = 0.1, end = 0.9, guide = "none", alpha = 0.75) +
scale_x_discrete(labels = c(Individual = "Individuo", "Song type" = "Tipo de\ncanto", Lek = "Lek", Site = "Sitio"))
sub_sp_lbh <- sp_feat_lbh_all[sp_feat_lbh_all$SNR > 1, ]
# Chunk 1: set root directory
knitr::opts_knit$set(root.dir = "..")
# Chunk 2: add link to github repo
# print link to github repo if any
if (file.exists("./.git/config")){
config <- readLines("./.git/config")
url <- grep("url",  config, value = TRUE)
url <- gsub("\\turl = |.git$", "", url)
cat("\nSource code and data found at [", url, "](", url, ")", sep = "")
}
# Chunk 3: setup style
# options to customize chunk outputs
knitr::opts_chunk$set(
tidy.opts = list(width.cutoff = 65),
tidy = TRUE,
message = FALSE,
warning = FALSE
)
# Chunk 4: load packages
# knitr is require for creating html/pdf/word reports
# formatR is used for soft-wrapping code
# install/ load packages
sketchy::load_packages(
packages = c(
"knitr",
"formatR",
"rprojroot",
github = "maRce10/warbleR",
github = "maRce10/baRulho",
"readxl",
"Rraven",
"ggplot2",
"brms",
"viridis",
"corrplot",
"DT",
"ape",
"phangorn",
"ggtree",
"phytools",
"ratematrix",
"geomorph",
"evolvability",
"geiger",
"ggdist",
"ggtree",
"gghalves",
"pbapply",
"mvMORPH",
"corrplot",
"caret",
"rptR",
"lme4",
"MASS",
"lmerTest",
"convevol",
"animation",
"Rraven",
"scales"
)
)
# Chunk 5
# get phylogenetic signal froma brms model object
phylo_sig_brms <- function(model) {
hyp <-
"sd_phylo__Intercept^2 / (sd_phylo__Intercept^2 + sigma^2) = 0"
hyp_test <- hypothesis(model, hyp, class = NULL)
return(hyp_test$hypothesis[1, c("Estimate", "CI.Lower", "CI.Upper", "Post.Prob")])
}
# match data and tree tip labels
match_data_tree <- function(data, tree, index) {
if (!is.null(dim(data))){
data <- data[index %in% tree$tip.label, ]
rownames(data) <- index[index %in% tree$tip.label]
} else {
data <- data[index %in% tree$tip.label]
names(data) <- index[index %in% tree$tip.label]
}
# prun tree
tree <- drop.tip(tree, tip = tree$tip.label[!tree$tip.label %in% index])
# return
out <- list(data = data, tree = tree)
return(out)
}
# compare evolutionary rates between features
CompareRates.multTrait <-  function(phy,x,TraitCov=T,ms.err=NULL,ms.cov=NULL){
#Compares LLik of R-matrix vs. LLik of R-matrix with constrained diagonal
#TraitCov = TRUE assumes covariation among traits (default)
#ms.err allows the incorporation of within-species measurement error. Input is a matrix of species (rows) by within-species
#variation for each trait (columns).
#ms.cov allows the incorporation of within-species covariation between traits. Input is a matrix of species (rows) by within-species
#covariation for each pair of traits (columns). These must be provided in a specific order, beginning with covariation between trait 1
#and the rest, then trait 2 and the rest, etc. For instance, for 4 traits, the columns are: cov_12, cov_13, cov_14, cov_23, cov_24 cov_34.
#Some calculations adapted from 'evol.vcv' in phytools (Revell, 2012)
x<-as.matrix(x)
N<-nrow(x)
p<-ncol(x)
C<-vcv.phylo(phy)
C<-C[rownames(x),rownames(x)]
if (is.matrix(ms.err)){
ms.err<-as.matrix(ms.err[rownames(x),])}
if (is.matrix(ms.cov)){
ms.cov<-as.matrix(ms.cov[rownames(x),])}
#Cholesky decomposition function for diagonal-constrained VCV
build.chol<-function(b){
c.mat<-matrix(0,nrow=p,ncol=p)
c.mat[lower.tri(c.mat)] <- b[-1]
c.mat[p,p]<-exp(b[1])
c.mat[1,1]<-sqrt(sum((c.mat[p,])^2))
if(p>2){
for (i in 2:(p-1)){
c.mat[i,i]<-ifelse( (c.mat[1,1]^2-sum((c.mat[i,])^2) )>0,
sqrt(c.mat[1,1]^2-sum((c.mat[i,])^2)), 0)
}}
return(c.mat)
}
#Fit Rate matrix for all traits: follows code of L. Revell (evol.vcv)
a.obs<-colSums(solve(C))%*%x/sum(solve(C))
D<-matrix(0,N*p,p)
for(i in 1:(N*p)) for(j in 1:p) if((j-1)*N<i&&i<=j*N) D[i,j]=1.0
y<-as.matrix(as.vector(x))
one<-matrix(1,N,1)
R.obs<-t(x-one%*%a.obs)%*%solve(C)%*%(x-one%*%a.obs)/N
if (TraitCov==F)    #for TraitCov = F
{ R.obs<-diag(diag(R.obs),p)  }
#Calculate observed likelihood with or without measurement error
LLik.obs<-ifelse(is.matrix(ms.err)==TRUE,
-t(y-D%*%t(a.obs))%*%ginv((kronecker(R.obs,C)+ diag(as.vector(ms.err))))%*%(y-D%*%t(a.obs))/2-N*p*log(2*pi)/2-
determinant((kronecker(R.obs,C)+ diag(as.vector(ms.err))))$modulus[1]/2 ,
-t(y-D%*%t(a.obs))%*%ginv(kronecker(R.obs,C))%*%(y-D%*%t(a.obs))/2-N*p*log(2*pi)/2-
determinant(kronecker(R.obs,C))$modulus[1]/2
)
#Fit common rate for all traits; search over parameter space
sigma.mn<-mean(diag(R.obs))   #reasonable start value for diagonal
#Within-species measurement error matrix
if(is.matrix(ms.err)){m.e<-diag(as.vector(ms.err))}
#Within-species measurement error and trait covariation matrix
if (is.matrix(ms.err) && is.matrix(ms.cov)){
within.spp<-cbind(ms.err,ms.cov)
rc.label<-NULL
for (i in 1:p){ rc.label<-rbind(rc.label,c(i,i)) }
for (i in 1:p){
for (j in 2:p){ if (i!=j && i<j){rc.label<-rbind(rc.label,c(i,j))} }}
m.e<-NULL
for (i in 1:p){
tmp<-NULL
for (j in 1:p){
for (k in 1:nrow(rc.label)){
if(setequal(c(i,j),rc.label[k,])==T) {tmp<-cbind(tmp,diag(within.spp[,k]))}
}
}
m.e<-rbind(m.e,tmp)
}
}
#likelihood optimizer for no trait covariation
lik.covF<-function(sigma){
R<-matrix(0,nrow=p,ncol=p)
diag(R)<-sigma
LLik<-ifelse(is.matrix(ms.err)==TRUE,
-t(y-D%*%t(a.obs))%*%ginv((kronecker(R,C)+ m.e))%*%(y-D%*%t(a.obs))/2-N*p*log(2*pi)/2-
determinant((kronecker(R,C)+ m.e))$modulus[1]/2 ,
-t(y-D%*%t(a.obs))%*%ginv(kronecker(R,C))%*%(y-D%*%t(a.obs))/2-N*p*log(2*pi)/2-
determinant(kronecker(R,C))$modulus[1]/2
)
if (LLik == -Inf) { LLikk <- -1e+10  }
return(-LLik)
}
#likelihood optimizer with trait covariation
lik.covT<-function(sigma){
low.chol<-build.chol(sigma)
R<-low.chol%*%t(low.chol)
LLik<-ifelse(is.matrix(ms.err)==TRUE,
-t(y-D%*%t(a.obs))%*%ginv((kronecker(R,C)+ m.e))%*%(y-D%*%t(a.obs))/2-N*p*log(2*pi)/2-
determinant((kronecker(R,C)+ m.e))$modulus[1]/2 ,
-t(y-D%*%t(a.obs))%*%ginv(kronecker(R,C))%*%(y-D%*%t(a.obs))/2-N*p*log(2*pi)/2-
determinant(kronecker(R,C))$modulus[1]/2
)
if (LLik == -Inf)  {LLikk <- -1e+10  }
return(-LLik)
}
##Optimize for no trait covariation (methods: "Nelder-Mead"  or "SANN")
if (TraitCov==F)
{ model1<-optim(sigma.mn,fn=lik.covF,method="L-BFGS-B",lower=c(0.0))}
##Optimize with trait covariation
R.offd<-rep(0,(p*(p-1)/2))
if (TraitCov==T)
{model1<-optim(par=c(sigma.mn,R.offd),fn=lik.covT,method="L-BFGS-B")}
#### Assemble R.constrained
if (TraitCov==F){R.constr<-diag(model1$par,p)}
if (TraitCov==T){
chol.mat<-build.chol(model1$par)
R.constr<-chol.mat%*%t(chol.mat)}
if(model1$convergence==0)
message<-"Optimization has converged."
else
message<-"Optim may not have converged.  Consider changing start value or lower/upper limits."
LRT<- (-2*((-model1$value-LLik.obs)))
LRT.prob<-pchisq(LRT, (p-1),lower.tail=FALSE) #df = Nvar-1
AIC.obs<- -2*LLik.obs+2*p+2*p #(2p twice: 1x for rates, 1x for anc. states)
AIC.common<- -2*(-model1$value)+2+2*p #(2*1: for 1 rate 2p for anc. states)
return(list(Robs=R.obs, Rconstrained=R.constr,Lobs=LLik.obs,Lconstrained=(-model1$value),LRTest=LRT,Prob=LRT.prob,
AICc.obs=AIC.obs,AICc.constrained=AIC.common,optimmessage=message))
}
cols_corr <- colorRampPalette(c(mako(3, direction = 1, begin = 0.2,
end = 0.5), "#BEBEBE1A", "white", "#BEBEBE1A",mako(3, direction = 1,
begin = 0.7, end = 0.9)))(30)
# Chunk 6: spectrorgram fig publication
sgmt.est <- readRDS("./data/processed/complete_segment_analysis_nov-2019.RDS")
sub_sp_lbh <- sp_feat_lbh_all[sp_feat_lbh_all$SNR > 1, ]
# read spectral features
sp_feat_lbh_all <- readRDS("./data/processed/spectro_features_ALL_Song selections aug 2019 SAME.FREQ.RANGE AND METADATA.RDS")
#| out_width = "100%"
gg_var_pc1 <- readRDS("~/Dropbox/Projects/lbh_cultural_evolution_pattern_and_process/output/plots/song_variance_contribution_spectro.RDS")
gg_var_pc1 <- gg_var_pc1 + scale_fill_manual(values = mako(4, begin = 0.1, end = 0.9, direction = 1, alpha = 0.9)[c(1, 3, 2, 4)]) +  theme(legend.position = "none")
# Data for the nested ovals
oval_data <- data.frame(
# label = c("A", "B", "C", "D"),
x0 = c(0, 0, 0, 0),                # Center x position for all ovals
y0 = c(-1.7, -0.4, 0.7, 2.2),                # Center y position for all ovals
b = c(1.5, 3, 4.5, 6),             # Semi-major axis (horizontal radius)
a = c(2, 4, 6, 8) + 1,                 # Semi-minor axis (vertical radius)
text.pos = c(-4.7, -2, 1, 3.2) + 3,  # Radius for each circle
label = rev(c("Sitio", "Lek", "Vecindario\nde canto", "Individuo"))  #
)
oval_data$label <- factor(oval_data$label, levels = (c("Sitio", "Lek", "Vecindario\nde canto", "Individuo")))
# Plot using ggplot2 and ggforce
oval_plot <- ggplot(oval_data) +
geom_ellipse(aes(x0 = x0, y0 = y0, a = a, b = b, angle = 0, fill = label), color = "white") +
geom_text(aes(x = x0, y = text.pos, label = label), size = c(6, 5, 6, 6), color = c( "white",rep("black", 3))) +
scale_fill_viridis_d(option = "G", begin = 0.1, end = 0.9, guide = "none", direction = -1, alpha = 0.6) + # Add labels in the center
# scale_fill_identity() +  # Use the colors as specified in the data
theme_void() +           # Remove background, axes, and grid
theme(legend.position = "none") +
coord_fixed()  #+          # Keep aspect ratio fixed for true ovals
#ylim(c(-12, 6))
cowplot::plot_grid(gg_var_pc1 +    scale_y_continuous(labels = label_percent(), limits = c(0, 0.7)), oval_plot, nrow = 1, rel_widths = c(1, 0.7))
ggplot(oval_data) +
geom_ellipse(aes(x0 = x0, y0 = y0, a = a, b = b, angle = 0, fill = label), color = "white") +
geom_text(aes(x = x0, y = text.pos, label = label), size = c(6, 5, 6, 6), color = c( "white",rep("black", 3))) +
scale_fill_viridis_d(option = "G", begin = 0.1, end = 0.9, guide = "none", direction = -1, alpha = 0.6) + # Add labels in the center
# scale_fill_identity() +  # Use the colors as specified in the data
theme_void() +           # Remove background, axes, and grid
theme(legend.position = "none") +
coord_fixed()  #+          # Keep aspect ratio fixed for true ovals
#ylim(c(-12, 6))
ggplot(oval_data) +
geom_ellipse(aes(x0 = x0, y0 = y0, a = a, b = b, angle = 0, fill = label), color = "white") +
geom_text(aes(x = x0, y = text.pos, label = label), size = c(6, 5, 6, 6), color = c( "white",rep("black", 3))) +
scale_fill_viridis_d(option = "G", begin = 0.1, end = 0.9, guide = "none", direction = -1, alpha = 0.6) + # Add labels in the center
# scale_fill_identity() +  # Use the colors as specified in the data
theme_void() +           # Remove background, axes, and grid
theme(legend.position = "none") +
coord_fixed()  #+          # Keep aspect ratio fixed for true ovals
#ylim(c(-12, 6))
blogdown::stop_server(); blogdown:::preview_site()
blogdown:::preview_site()
blogdown:::preview_site()
blogdown:::preview_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::serve_site()
blogdown::stop_server()
Sys.sleep(1)
blogdown::build_site()
Sys.sleep(1)
blogdown::serve_site()
blogdown:::preview_site()
blogdown::stop_server()
blogdown::build_site()
blogdown::serve_site()
blogdown::stop_server()
blogdown::build_site()
blogdown::serve_site()
blogdown:::preview_site()
blogdown:::preview_site()
blogdown::stop_server()
blogdown::serve_site()
blogdown::stop_server()
blogdown::serve_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::stop_server()
blogdown::serve_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::build_site()
blogdown::stop_server()
blogdown::build_site()
blogdown::serve_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::stop_server()
blogdown::serve_site()
blogdown::build_site()
blogdown::stop_server()
blogdown::serve_site()
blogdown::stop_server()
blogdown::build_site()
blogdown::serve_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::stop_server()
blogdown::build_site()
blogdown::serve_site()
blogdown::stop_server()
blogdown::build_site()
blogdown::serve_site()
blogdown::stop_server()
blogdown::build_site()
blogdown::serve_site()
blogdown::build_site()
blogdown::serve_site()
blogdown::build_site()
blogdown::stop_server()
blogdown::serve_site()
blogdown::stop_server()
blogdown::build_site()
blogdown::serve_site()
blogdown:::preview_site()
